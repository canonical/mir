use std::path::Path;
use std::fs;
use std::collections::{HashSet, HashMap};
use quick_xml::Reader;
use quick_xml::events::Event;

#[derive(Debug, Clone)]
struct RequestArg {
    name: String,
    arg_type: String,
    interface: Option<String>,
    allow_null: bool,
}

#[derive(Debug, Clone)]
struct Request {
    name: String,
    args: Vec<RequestArg>,
}

#[derive(Debug, Clone)]
struct InterfaceInfo {
    name: String,
    requests: Vec<Request>,
}

fn main() {
    let wayland_generated_dir = "src";
    let protocol_filename = "protocols.rs";
    let protocol_dest_path = Path::new(&wayland_generated_dir).join(protocol_filename);
    let dispatchers_filename = "dispatchers.rs";
    let dispatchers_dest_path = Path::new(&wayland_generated_dir).join(dispatchers_filename);
    let ffi_cpp_dest_path = Path::new(&wayland_generated_dir).join("ffi_cpp.rs");
    let cpp_header_path = Path::new(&wayland_generated_dir).join("wayland_bridge_cpp.h");
    
    let wayland_protocols_xml_dir = fs::read_dir("../../wayland-protocols").unwrap();

    // Build the wayland protocols and the dispatchers module

    let mut protocol_rs_str = String::from("// This file is autogenerated by build.rs\n\n");
    let mut dispatchers_rs_str = String::from("// This file is autogenerated by build.rs\n\nuse wayland_server::Resource;\n");
    dispatchers_rs_str.push_str("use std::os::fd::{AsRawFd, OwnedFd};\n\n");
    let mut ffi_cpp_rs_str = String::from("// This file is autogenerated by build.rs\n\n");
    ffi_cpp_rs_str.push_str("#[cxx::bridge(namespace=\"mir::wayland_rs::cpp\")]\n");
    ffi_cpp_rs_str.push_str("pub mod ffi_cpp {\n");
    ffi_cpp_rs_str.push_str("    /// Wrapper type for passing Wayland resource references between Rust and C++\n");
    ffi_cpp_rs_str.push_str("    #[derive(Clone)]\n");
    ffi_cpp_rs_str.push_str("    pub struct WaylandResource {\n");
    ffi_cpp_rs_str.push_str("        pub object_id: u32,\n");
    ffi_cpp_rs_str.push_str("    }\n\n");
    ffi_cpp_rs_str.push_str("    /// Wrapper type for optional Wayland resource references\n");
    ffi_cpp_rs_str.push_str("    #[derive(Clone)]\n");
    ffi_cpp_rs_str.push_str("    pub struct OptionalWaylandResource {\n");
    ffi_cpp_rs_str.push_str("        pub object_id: u32,\n");
    ffi_cpp_rs_str.push_str("        pub is_null: bool,\n");
    ffi_cpp_rs_str.push_str("    }\n\n");
    ffi_cpp_rs_str.push_str("    unsafe extern \"C++\" {\n");

    // TODO: Readd this back
    ffi_cpp_rs_str.push_str("        include!(\"src/wayland_bridge_cpp.h\");\n\n");

    let mut all_interface_info: HashMap<String, InterfaceInfo> = HashMap::new();
    
    for protocol_file in wayland_protocols_xml_dir {
        let path = protocol_file.unwrap().path();
        if path.extension().and_then(|s| s.to_str()) == Some("xml") {
            // First, generate the generator macros.
            let protocol_name = path.file_stem().and_then(|s| s.to_str()).unwrap();
            if protocol_name != "wayland" {
                protocol_rs_str.push_str(&format!("pub mod {} {{\n", protocol_name.replace('-', "_")));
                protocol_rs_str.push_str("    use wayland_server;\n");
                protocol_rs_str.push_str("    use wayland_server::protocol::*;\n");
                protocol_rs_str.push_str("    use wayland_server::protocol::__interfaces::*;\n");
    
                // TODO: We can probably be smarter and read the protocol to parse out its dependencies,
                // but this is easy enough for now.
                if protocol_name == "xdg-decoration-unstable-v1" || protocol_name == "xdg-activation-v1" || protocol_name == "wlr-layer-shell-unstable-v1" {
                    protocol_rs_str.push_str("    use crate::protocols::xdg_shell::*;\n");
                }
    
                if protocol_name == "input-method-unstable-v2" {
                    protocol_rs_str.push_str("    use crate::protocols::text_input_unstable_v3::*;\n");
                }
    
                if protocol_name == "ext-image-capture-source-v1" {
                    protocol_rs_str.push_str("    use crate::protocols::ext_foreign_toplevel_list_v1::*;\n");
                }
    
                if protocol_name == "ext-image-copy-capture-v1" {
                    protocol_rs_str.push_str("    use crate::protocols::ext_image_capture_source_v1::*;\n");
                    protocol_rs_str.push_str("    use crate::protocols::ext_image_capture_source_v1::ext_image_capture_source_v1::*;\n");
                }
    
                protocol_rs_str.push_str("    wayland_scanner::generate_interfaces!(\"");
                protocol_rs_str.push_str(&format!("../../wayland-protocols/{}.xml\");\n", protocol_name));
                protocol_rs_str.push_str("    wayland_scanner::generate_server_code!(\"");
                protocol_rs_str.push_str(&format!("../../wayland-protocols/{}.xml\");\n", protocol_name));
                protocol_rs_str.push_str("}\n");
                continue;
            }


            // Next, generate the dispatchers.
            // TODO: This should include the "wayland" protocol as well.
            
            // Parse the XML to generate dispatcher implementations
            let mut reader = Reader::from_file(&path).expect("Failed to open XML file");
            reader.config_mut().trim_text(true);
            
            let mut interfaces = Vec::new();
            let mut created_interfaces = HashSet::new();
            let mut buf = Vec::new();
            let mut in_protocol = false;
            let mut in_interface = false;
            let mut in_request = false;
            let mut current_interface = String::new();
            let mut current_request: Option<Request> = None;
            let mut interface_requests: HashMap<String, Vec<Request>> = HashMap::new();
            let mut depth = 0;
            
            // First pass: collect all interfaces, created interfaces, and requests
            loop {
                match reader.read_event_into(&mut buf) {
                    Ok(Event::Start(ref e)) => {
                        depth += 1;
                        match e.name().as_ref() {
                            b"protocol" => in_protocol = true,
                            b"interface" if depth == 2 && in_protocol => {
                                in_interface = true;
                                if let Some(name_attr) = e.attributes()
                                    .filter_map(|a| a.ok())
                                    .find(|a| a.key.as_ref() == b"name") {
                                    current_interface = String::from_utf8_lossy(&name_attr.value).to_string();

                                    if current_interface == "wl_display" || current_interface == "wl_registry" {
                                        // Skip wl_display and wl_registry interfaces
                                        in_interface = false;
                                        current_interface.clear();
                                    } else {
                                        interfaces.push(current_interface.clone());
                                        interface_requests.insert(current_interface.clone(), Vec::new());
                                    }
                                }
                            },
                            b"request" if in_interface => {
                                in_request = true;
                                let mut request_name = String::new();
                                for attr in e.attributes().filter_map(|a| a.ok()) {
                                    if attr.key.as_ref() == b"name" {
                                        request_name = String::from_utf8_lossy(&attr.value).to_string();
                                        break;
                                    }
                                }
                                current_request = Some(Request {
                                    name: request_name,
                                    args: Vec::new(),
                                });
                            },
                            b"arg" if in_request => {
                                if let Some(ref mut req) = current_request {
                                    let mut arg_name = String::new();
                                    let mut arg_type = String::new();
                                    let mut arg_interface: Option<String> = None;
                                    let mut allow_null = false;
                                    
                                    for attr in e.attributes().filter_map(|a| a.ok()) {
                                        match attr.key.as_ref() {
                                            b"name" => arg_name = String::from_utf8_lossy(&attr.value).to_string(),
                                            b"type" => arg_type = String::from_utf8_lossy(&attr.value).to_string(),
                                            b"interface" => {
                                                let iface = String::from_utf8_lossy(&attr.value).to_string();
                                                created_interfaces.insert(iface.clone());
                                                arg_interface = Some(iface);
                                            },
                                            b"allow-null" => {
                                                allow_null = String::from_utf8_lossy(&attr.value) == "true";
                                            },
                                            _ => {}
                                        }
                                    }
                                    
                                    req.args.push(RequestArg {
                                        name: arg_name,
                                        arg_type,
                                        interface: arg_interface,
                                        allow_null,
                                    });
                                }
                            },
                            _ => {}
                        }
                    },
                    Ok(Event::Empty(ref e)) => {
                        // Handle self-closing tags (like <arg ... />)
                        match e.name().as_ref() {
                            b"arg" if in_request => {
                                if let Some(ref mut req) = current_request {
                                    let mut arg_name = String::new();
                                    let mut arg_type = String::new();
                                    let mut arg_interface: Option<String> = None;
                                    let mut allow_null = false;
                                    
                                    for attr in e.attributes().filter_map(|a| a.ok()) {
                                        match attr.key.as_ref() {
                                            b"name" => arg_name = String::from_utf8_lossy(&attr.value).to_string(),
                                            b"type" => arg_type = String::from_utf8_lossy(&attr.value).to_string(),
                                            b"interface" => {
                                                let iface = String::from_utf8_lossy(&attr.value).to_string();
                                                created_interfaces.insert(iface.clone());
                                                arg_interface = Some(iface);
                                            },
                                            b"allow-null" => {
                                                allow_null = String::from_utf8_lossy(&attr.value) == "true";
                                            },
                                            _ => {}
                                        }
                                    }
                                    
                                    req.args.push(RequestArg {
                                        name: arg_name,
                                        arg_type,
                                        interface: arg_interface,
                                        allow_null,
                                    });
                                }
                            },
                            b"request" if in_interface => {
                                // Self-closing request (no args)
                                let mut request_name = String::new();
                                for attr in e.attributes().filter_map(|a| a.ok()) {
                                    if attr.key.as_ref() == b"name" {
                                        request_name = String::from_utf8_lossy(&attr.value).to_string();
                                        break;
                                    }
                                }
                                if let Some(requests) = interface_requests.get_mut(&current_interface) {
                                    requests.push(Request {
                                        name: request_name,
                                        args: Vec::new(),
                                    });
                                }
                            },
                            _ => {}
                        }
                    },
                    Ok(Event::End(ref e)) => {
                        match e.name().as_ref() {
                            b"protocol" => in_protocol = false,
                            b"interface" => {
                                in_interface = false;
                                current_interface.clear();
                            },
                            b"request" => {
                                if let Some(req) = current_request.take() {
                                    if let Some(requests) = interface_requests.get_mut(&current_interface) {
                                        requests.push(req);
                                    }
                                }
                                in_request = false;
                            },
                            _ => {}
                        }
                        depth -= 1;
                    },
                    Ok(Event::Eof) => break,
                    Err(e) => panic!("Error parsing XML at position {}: {:?}", reader.buffer_position(), e),
                    _ => {}
                }
                buf.clear();
            }
            
            // Helper function to convert snake_case to PascalCase
            let to_pascal_case = |s: &str| -> String {
                s.split('_')
                    .map(|word| {
                        let mut chars = word.chars();
                        match chars.next() {
                            None => String::new(),
                            Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                        }
                    })
                    .collect()
            };
            
            // Store interface info for later use
            for interface in &interfaces {
                let requests = interface_requests.get(interface).cloned().unwrap_or_default();
                all_interface_info.insert(
                    interface.clone(),
                    InterfaceInfo {
                        name: interface.clone(),
                        requests,
                    }
                );
            }
            
            // Generate imports for this protocol's interfaces
            for interface in &interfaces {
                let type_name = to_pascal_case(interface);
                if protocol_name != "wayland" {
                    dispatchers_rs_str.push_str(&format!(
                        "use crate::protocols::{}::{}::{};\n",
                        protocol_name.replace('-', "_"),
                        interface,
                        type_name
                    ));
                } else if interface != "wl_display" {
                    dispatchers_rs_str.push_str(&format!(
                        "use wayland_server::protocol::{}::{};\n",
                        interface,
                        type_name
                    ));
                }
            }
            dispatchers_rs_str.push('\n');
            
            // Generate Send/Sync trait implementations for handler types
            for interface in &interfaces {
                let type_name = to_pascal_case(interface);
                dispatchers_rs_str.push_str(&format!("unsafe impl Send for crate::ffi_cpp::ffi_cpp::{}Handler {{}}\n", type_name));
                dispatchers_rs_str.push_str(&format!("unsafe impl Sync for crate::ffi_cpp::ffi_cpp::{}Handler {{}}\n", type_name));
            }
            dispatchers_rs_str.push('\n');
            
            // Generate wrapper types for handler pointers (to make them Send/Sync)
            for interface in &interfaces {
                let type_name = to_pascal_case(interface);
                dispatchers_rs_str.push_str(&format!("#[repr(transparent)]\n"));
                dispatchers_rs_str.push_str(&format!("pub struct {}HandlerPtr(*mut crate::ffi_cpp::ffi_cpp::{}Handler);\n", type_name, type_name));
                dispatchers_rs_str.push_str(&format!("unsafe impl Send for {}HandlerPtr {{}}\n", type_name));
                dispatchers_rs_str.push_str(&format!("unsafe impl Sync for {}HandlerPtr {{}}\n", type_name));
                dispatchers_rs_str.push_str(&format!("impl std::ops::Deref for {}HandlerPtr {{\n", type_name));
                dispatchers_rs_str.push_str(&format!("    type Target = *mut crate::ffi_cpp::ffi_cpp::{}Handler;\n", type_name));
                dispatchers_rs_str.push_str("    fn deref(&self) -> &Self::Target { &self.0 }\n");
                dispatchers_rs_str.push_str("}\n");
            }
            dispatchers_rs_str.push('\n');
            
            // Generate trait implementations
            for interface in &interfaces {
                let type_name = to_pascal_case(interface);
                let is_global = !created_interfaces.contains(interface);
                let handler_wrapper_type = format!("{}HandlerPtr", type_name);
                
                // Generate GlobalDispatch for globals only
                if is_global {
                    dispatchers_rs_str.push_str(&format!(
                        "impl wayland_server::GlobalDispatch<{}, ()> for crate::ServerState {{\n",
                        type_name
                    ));
                    dispatchers_rs_str.push_str("    fn bind(\n");
                    dispatchers_rs_str.push_str("        _state: &mut Self,\n");
                    dispatchers_rs_str.push_str("        _handle: &wayland_server::DisplayHandle,\n");
                    dispatchers_rs_str.push_str("        _client: &wayland_server::Client,\n");
                    dispatchers_rs_str.push_str(&format!("        resource: wayland_server::New<{}>,\n", type_name));
                    dispatchers_rs_str.push_str("        _global_data: &(),\n");
                    dispatchers_rs_str.push_str("        data_init: &mut wayland_server::DataInit<'_, Self>,\n");
                    dispatchers_rs_str.push_str("    ) {\n");
                    dispatchers_rs_str.push_str("        use crate::ffi_cpp::ffi_cpp::HandlerFactory;\n");
                    dispatchers_rs_str.push_str("        let factory = _state.get_handler_factory();\n");
                    dispatchers_rs_str.push_str(&format!(
                        "        let handler = factory.create_{}_handler();\n",
                        interface
                    ));
                    dispatchers_rs_str.push_str(&format!("        data_init.init(resource, {}HandlerPtr(handler));\n", type_name));
                    dispatchers_rs_str.push_str("    }\n");
                    dispatchers_rs_str.push_str("}\n\n");
                }
                
                // Generate Dispatch for all interfaces
                dispatchers_rs_str.push_str(&format!(
                    "impl wayland_server::Dispatch<{}, {}> for crate::ServerState {{\n",
                    type_name, handler_wrapper_type
                ));
                dispatchers_rs_str.push_str("    fn request(\n");
                dispatchers_rs_str.push_str("        _state: &mut Self,\n");
                dispatchers_rs_str.push_str("        _client: &wayland_server::Client,\n");
                dispatchers_rs_str.push_str(&format!("        _resource: &{},\n", type_name));
                dispatchers_rs_str.push_str(&format!("        request: <{} as wayland_server::Resource>::Request,\n", type_name));
                dispatchers_rs_str.push_str(&format!("        data: &{},\n", handler_wrapper_type));
                dispatchers_rs_str.push_str("        _dhandle: &wayland_server::DisplayHandle,\n");
                dispatchers_rs_str.push_str("        _data_init: &mut wayland_server::DataInit<'_, Self>,\n");
                dispatchers_rs_str.push_str("    ) {\n");
                dispatchers_rs_str.push_str("        use crate::ffi_cpp::ffi_cpp::HandlerFactory;\n");
                dispatchers_rs_str.push_str("        let factory = _state.get_handler_factory();\n");
                dispatchers_rs_str.push('\n');
                
                // Get the requests for this interface
                let interface_info = all_interface_info.get(interface);
                if let Some(info) = interface_info {
                    if !info.requests.is_empty() {
                        dispatchers_rs_str.push_str("        use crate::ffi_cpp::ffi_cpp::*;\n");
                        let type_name = to_pascal_case(interface);
                        if protocol_name != "wayland" {
                            dispatchers_rs_str.push_str(&format!(
                                "        use crate::protocols::{}::{}::Request as {}Request;;\n",
                                protocol_name.replace('-', "_"),
                                interface,
                                type_name
                            ));
                        } else if interface != "wl_display" {
                            dispatchers_rs_str.push_str(&format!(
                                "        use wayland_server::protocol::{}::Request as {}Request;\n",
                                interface,
                                type_name
                            ));
                        }

                        dispatchers_rs_str.push_str("        match request {\n");
                        
                        for request in &info.requests {
                            let request_variant = to_pascal_case(&request.name);
                            dispatchers_rs_str.push_str(&format!("            {}Request::{}", type_name, request_variant));
                            
                            if request.args.is_empty() {
                                dispatchers_rs_str.push_str(" => {\n");
                            } else {
                                dispatchers_rs_str.push_str(" { ");
                                for (i, arg) in request.args.iter().enumerate() {
                                    if i > 0 {
                                        dispatchers_rs_str.push_str(", ");
                                    }
                                    dispatchers_rs_str.push_str(&arg.name);
                                }
                                dispatchers_rs_str.push_str(" } => {\n");
                            }
                            
                            // Check if we need to initialize any new_id resources first
                            let has_new_id = request.args.iter().any(|arg| arg.arg_type == "new_id");
                            
                            if has_new_id {
                                dispatchers_rs_str.push_str("                // Initialize new resources\n");
                                for arg in &request.args {
                                    if arg.arg_type == "new_id" {
                                        if let Some(interface_name) = &arg.interface {
                                            let child_type_name = to_pascal_case(interface_name);
                                            dispatchers_rs_str.push_str(&format!(
                                                "                let {}_handler = factory.create_{}_handler();\n",
                                                arg.name, interface_name
                                            ));
                                            dispatchers_rs_str.push_str(&format!(
                                                "                let {}_initialized = _data_init.init({}, {}HandlerPtr({}_handler));\n",
                                                arg.name, arg.name, child_type_name, arg.name
                                            ));
                                        } else {
                                            // No interface means generic object - we can't create a handler yet
                                            dispatchers_rs_str.push_str(&format!(
                                                "                let {}_initialized = _data_init.init({}, std::ptr::null_mut());\n",
                                                arg.name, arg.name
                                            ));
                                        }
                                    }
                                }
                                dispatchers_rs_str.push('\n');
                            }
                            
                            // Generate handler call
                            dispatchers_rs_str.push_str("                unsafe {\n");
                            dispatchers_rs_str.push_str("                    if let Some(handler) = data.0.as_ref() {\n");
                            dispatchers_rs_str.push_str(&format!("                        handler.handle_{}(", request.name));
                            
                            for (i, arg) in request.args.iter().enumerate() {
                                if i > 0 {
                                    dispatchers_rs_str.push_str(", ");
                                }
                                
                                // Convert arguments as needed
                                match arg.arg_type.as_str() {
                                    "string" => {
                                        dispatchers_rs_str.push_str(&format!("{}.as_str()", arg.name));
                                    },
                                    "new_id" => {
                                        dispatchers_rs_str.push_str(&format!(
                                            "&WaylandResource {{ object_id: {}_initialized.id().protocol_id() }}",
                                            arg.name
                                        ));
                                    },
                                    "object" => {
                                        if arg.allow_null {
                                            dispatchers_rs_str.push_str(&format!(
                                                "&OptionalWaylandResource {{ object_id: {}.map(|o| o.id().protocol_id()).unwrap_or(0), is_null: {}.is_none() }}",
                                                arg.name, arg.name
                                            ));
                                        } else {
                                            dispatchers_rs_str.push_str(&format!(
                                                "&WaylandResource {{ object_id: {}.id().protocol_id() }}",
                                                arg.name
                                            ));
                                        }
                                    },
                                    "array" => {
                                        dispatchers_rs_str.push_str(&format!("{}.as_slice()", arg.name));
                                    },
                                    "uint" => {
                                        dispatchers_rs_str.push_str(&format!("{}.into()", arg.name));
                                    },
                                    "fd" => {
                                        dispatchers_rs_str.push_str(&format!("{}.as_raw_fd()", arg.name));
                                    },
                                    _ => {
                                        dispatchers_rs_str.push_str(&arg.name);
                                    }
                                }
                            }
                            
                            dispatchers_rs_str.push_str(");\n");
                            dispatchers_rs_str.push_str("                    }\n");
                            dispatchers_rs_str.push_str("                }\n");
                            dispatchers_rs_str.push_str("            }\n");
                        }
                        
                        dispatchers_rs_str.push_str("            _ => {}\n");
                        dispatchers_rs_str.push_str("        }\n");
                    } else {
                        dispatchers_rs_str.push_str("        match request {\n");
                        dispatchers_rs_str.push_str("            _ => {}\n");
                        dispatchers_rs_str.push_str("        }\n");
                    }
                } else {
                    dispatchers_rs_str.push_str("        match request {\n");
                    dispatchers_rs_str.push_str("            _ => {}\n");
                    dispatchers_rs_str.push_str("        }\n");
                }
                
                dispatchers_rs_str.push_str("    }\n");
                dispatchers_rs_str.push_str("}\n\n");
            }

        }
    }
    
    // Helper function to convert snake_case to PascalCase
    let to_pascal_case = |s: &str| -> String {
        s.split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                }
            })
            .collect()
    };
    
    // Helper function to convert Wayland type to Rust type for cxx
    let wayland_type_to_rust = |arg_type: &str, allow_null: bool| -> String {
        match arg_type {
            "int" => "i32".to_string(),
            "uint" => "u32".to_string(),
            "fixed" => "f64".to_string(),  // Wayland fixed-point is represented as i32
            "string" => "&str".to_string(),
            "object" | "new_id" => {
                if allow_null {
                    "&OptionalWaylandResource".to_string()
                } else {
                    "&WaylandResource".to_string()
                }
            },
            "array" => "&[u8]".to_string(),
            "fd" => "i32".to_string(),  // File descriptor
            _ => "i32".to_string(),  // Default fallback
        }
    };
    
    // Helper function to sanitize argument names (avoid C++ keywords)
    let sanitize_arg_name = |name: &str| -> String {
        match name {
            "namespace" => "namespace_".to_string(),
            "class" => "class_".to_string(),
            "template" => "template_".to_string(),
            "operator" => "operator_".to_string(),
            "delete" => "delete_".to_string(),
            "new" => "new_".to_string(),
            _ => name.to_string(),
        }
    };
    
    // Generate ffi_cpp handler types and methods
    for (interface_name, interface_info) in &all_interface_info {
        let type_name = to_pascal_case(interface_name);
        
        // Declare handler type
        ffi_cpp_rs_str.push_str(&format!("        pub type {}Handler;\n", type_name));
        
        // Declare handler methods for each request
        for request in &interface_info.requests {
            let method_name = format!("handle_{}", request.name);
            ffi_cpp_rs_str.push_str(&format!("        pub fn {}(self: &{}Handler", method_name, type_name));
            
            // Add parameters
            for arg in &request.args {
                let rust_type = wayland_type_to_rust(&arg.arg_type, arg.allow_null);
                let arg_name = sanitize_arg_name(&arg.name);
                ffi_cpp_rs_str.push_str(&format!(", {}: {}", arg_name, rust_type));
            }
            
            ffi_cpp_rs_str.push_str(");\n");
        }
        
        ffi_cpp_rs_str.push('\n');
    }
    
    // Declare HandlerFactory type and methods
    ffi_cpp_rs_str.push_str("        pub type HandlerFactory;\n");
    for interface_name in all_interface_info.keys() {
        let type_name = to_pascal_case(interface_name);
        let factory_method_name = format!("create_{}_handler", interface_name);
        ffi_cpp_rs_str.push_str(&format!(
            "        pub fn {}(self: &HandlerFactory) -> *mut {}Handler;\n",
            factory_method_name, type_name
        ));
    }
    ffi_cpp_rs_str.push('\n');
    
    ffi_cpp_rs_str.push_str("    }\n");
    ffi_cpp_rs_str.push_str("}\n");
    
    // Generate C++ header file
    let mut cpp_header_str = String::from("// This file is autogenerated by build.rs\n\n");
    cpp_header_str.push_str("#ifndef MIR_WAYLAND_BRIDGE_CPP_H\n#define MIR_WAYLAND_BRIDGE_CPP_H\n\n");
    cpp_header_str.push_str("#include <cstdint>\n\n");
    cpp_header_str.push_str("#include <rust/cxx.h>\n");
    cpp_header_str.push_str("#include <wayland-server-core.h>\n\n");
    cpp_header_str.push_str("namespace mir::wayland_rs::cpp {\n\n");
    cpp_header_str.push_str("    // Forward declarations for wrapper types\n");
    cpp_header_str.push_str("    struct WaylandResource;\n");
    cpp_header_str.push_str("    struct OptionalWaylandResource;\n\n");
    
    // Helper function to convert Wayland type to C++ type
    let wayland_type_to_cpp = |arg_type: &str, allow_null: bool| -> String {
        match arg_type {
            "int" => "int32_t".to_string(),
            "uint" => "uint32_t".to_string(),
            "fixed" => "double".to_string(),
            "string" => "rust::Str".to_string(),
            "object" | "new_id" => {
                if allow_null {
                    "OptionalWaylandResource const&".to_string()
                } else {
                    "WaylandResource const&".to_string()
                }
            },
            "array" => "rust::Slice<const uint8_t>".to_string(),
            "fd" => "int32_t".to_string(),
            _ => "int32_t".to_string(),
        }
    };
    
    // Generate handler base classes
    for (interface_name, interface_info) in &all_interface_info {
        let type_name = to_pascal_case(interface_name);
        
        cpp_header_str.push_str(&format!("/// Handler for {} Wayland protocol interface\n", interface_name));
        cpp_header_str.push_str(&format!("class {}Handler {{\n", type_name));
        cpp_header_str.push_str("public:\n");
        cpp_header_str.push_str(&format!("    virtual ~{}Handler() = default;\n\n", type_name));
        
        // Generate virtual methods for each request
        for request in &interface_info.requests {
            let method_name = format!("handle_{}", request.name);
            cpp_header_str.push_str(&format!("    virtual void {}(", method_name));
            
            // Add parameters
            for (i, arg) in request.args.iter().enumerate() {
                if i > 0 {
                    cpp_header_str.push_str(", ");
                }
                let cpp_type = wayland_type_to_cpp(&arg.arg_type, arg.allow_null);
                let arg_name = sanitize_arg_name(&arg.name);
                cpp_header_str.push_str(&format!("{} {}", cpp_type, arg_name));
            }
            
            cpp_header_str.push_str(") const = 0;\n");
        }
        
        cpp_header_str.push_str("};\n\n");
    }
    
    // Generate HandlerFactory base class
    cpp_header_str.push_str("/// Factory for creating protocol handlers\n");
    cpp_header_str.push_str("/// Implementors must override all virtual methods to provide handler instances\n");
    cpp_header_str.push_str("class HandlerFactory {\n");
    cpp_header_str.push_str("public:\n");
    cpp_header_str.push_str("    virtual ~HandlerFactory() = default;\n\n");
    
    // Generate factory method for each interface
    for interface_name in all_interface_info.keys() {
        let type_name = to_pascal_case(interface_name);
        let factory_method_name = format!("create_{}_handler", interface_name);
        
        cpp_header_str.push_str(&format!(
            "    virtual {}Handler* {}() const = 0;\n",
            type_name, factory_method_name
        ));
    }
    
    cpp_header_str.push_str("};\n\n");
    
    // Close namespace
    cpp_header_str.push_str("}  // namespace mir::wayland_rs::cpp\n\n");
    
    cpp_header_str.push_str("\n#endif // MIR_WAYLAND_BRIDGE_CPP_H\n");

    fs::write(
        &protocol_dest_path,
        protocol_rs_str
    ).unwrap();
    fs::write(
        &dispatchers_dest_path,
        dispatchers_rs_str
    ).unwrap();
    fs::write(
        &ffi_cpp_dest_path,
        ffi_cpp_rs_str
    ).unwrap();
    fs::write(
        &cpp_header_path,
        cpp_header_str
    ).unwrap();
    
    // Now build the cxx bridges after generating the required files
    // The lib.rs file includes both ffif_rust and ffi_cpp modules
    cxx_build::bridges(vec!["src/lib.rs", "src/ffi_cpp.rs"])
        .include(".") // Include current directory for wayland_bridge_cpp.h
        .compile("wayland_rs");

    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=../../wayland-protocols");
    println!("cargo:rerun-if-changed=build.rs");
}
