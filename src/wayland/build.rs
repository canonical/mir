use std::env;
use std::path::Path;
use std::fs;

fn main() {
    cxx_build::bridge("src/lib.rs")
        .compile("wayland_rs");

    let wayland_protocols_xml_dir = fs::read_dir("../../wayland-protocols").unwrap();

    // Build the wayland protocols and the dispatchers module
    let wayland_generated_dir = "src";
    let protocol_filename = "protocols.rs";
    let protocol_dest_path = Path::new(&wayland_generated_dir).join(protocol_filename);
    let dispatchers_filename = "dispatchers.rs";
    let dispatchers_dest_path = Path::new(&wayland_generated_dir).join(dispatchers_filename);

    let mut protocol_rs_str = String::from("// This file is autogenerated by build.rs\n\n");
    let mut dispatchers_rs_str = String::from("// This file is autogenerated by build.rs\n\n");
    for protocol_file in wayland_protocols_xml_dir {
        let path = protocol_file.unwrap().path();
        if path.extension().and_then(|s| s.to_str()) == Some("xml") {
            // First, generate the generator macros.
            let protocol_name = path.file_stem().and_then(|s| s.to_str()).unwrap();
            if protocol_name == "wayland" {
                continue;
            }

            protocol_rs_str.push_str(&format!("pub mod {} {{\n", protocol_name.replace('-', "_")));
            protocol_rs_str.push_str("    use wayland_server;\n");
            protocol_rs_str.push_str("    use wayland_server::protocol::*;\n");
            protocol_rs_str.push_str("    use wayland_server::protocol::__interfaces::*;\n");

            // TODO: We can probably be smarter and read the protocol to parse out its dependencies,
            // but this is easy enough for now.
            if protocol_name == "xdg-decoration-unstable-v1" || protocol_name == "xdg-activation-v1" || protocol_name == "wlr-layer-shell-unstable-v1" {
                protocol_rs_str.push_str("    use crate::protocols::xdg_shell::*;\n");
            }

            if protocol_name == "input-method-unstable-v2" {
                protocol_rs_str.push_str("    use crate::protocols::text_input_unstable_v3::*;\n");
            }

            if protocol_name == "ext-image-capture-source-v1" {
                protocol_rs_str.push_str("    use crate::protocols::ext_foreign_toplevel_list_v1::*;\n");
            }

            if protocol_name == "ext-image-copy-capture-v1" {
                protocol_rs_str.push_str("    use crate::protocols::ext_image_capture_source_v1::*;\n");
                protocol_rs_str.push_str("    use crate::protocols::ext_image_capture_source_v1::ext_image_capture_source_v1::*;\n");
            }

            protocol_rs_str.push_str("    wayland_scanner::generate_interfaces!(\"");
            protocol_rs_str.push_str(&format!("../../wayland-protocols/{}.xml\");\n", protocol_name));
            protocol_rs_str.push_str("    wayland_scanner::generate_server_code!(\"");
            protocol_rs_str.push_str(&format!("../../wayland-protocols/{}.xml\");\n", protocol_name));
            protocol_rs_str.push_str("}\n");

            // Next, generate the dispatchers.
            // TODO: This should include the "wayland" protocol as well.
            
        }
    }

    fs::write(
        &protocol_dest_path,
        protocol_rs_str
    ).unwrap();

    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=../../wayland-protocols");
    println!("cargo:rerun-if-changed=build.rs");
}
