use std::path::Path;
use std::fs;
use std::collections::{HashSet, HashMap};
use quick_xml::Reader;
use quick_xml::events::Event;

#[derive(Debug, Clone)]
struct RequestArg {
    name: String,
    arg_type: String,
    interface: Option<String>,
    allow_null: bool,
    enum_type: Option<String>,
}

#[derive(Debug, Clone)]
struct Request {
    name: String,
    args: Vec<RequestArg>,
}

#[derive(Debug, Clone)]
struct InterfaceInfo {
    name: String,
    requests: Vec<Request>,
}

fn main() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let wayland_generated_dir = "src";
    let protocol_filename = "protocols.rs";
    let protocol_dest_path = Path::new(&wayland_generated_dir).join(protocol_filename);
    let dispatchers_filename = "dispatchers.rs";
    let dispatchers_dest_path = Path::new(&wayland_generated_dir).join(dispatchers_filename);
    let ffi_cpp_dest_path = Path::new(&wayland_generated_dir).join("ffi_cpp.rs");
    let globals_filename = "generated_globals.rs";
    let globals_dest_path = Path::new(&wayland_generated_dir).join(globals_filename);
    let ffi_bridge_filename = "generated_ffi_bridge.rs";
    let ffi_bridge_dest_path = Path::new(&wayland_generated_dir).join(ffi_bridge_filename);

    let wayland_protocols_xml_dir = fs::read_dir("../../wayland-protocols").unwrap();

    // Build the wayland protocols and the dispatchers module

    let mut protocol_rs_str = String::from("// This file is autogenerated by build.rs\n\n");
    let mut dispatchers_rs_str = String::from("// This file is autogenerated by build.rs\n\nuse wayland_server::Resource;\n");
    dispatchers_rs_str.push_str("use std::os::fd::{AsRawFd, OwnedFd};\n\n");
    let mut ffi_cpp_rs_str = String::from("// This file is autogenerated by build.rs\n\n");
    ffi_cpp_rs_str.push_str("#[cxx::bridge(namespace=\"mir::wayland_rs::cpp\")]\n");
    ffi_cpp_rs_str.push_str("pub mod ffi_cpp {\n");
    ffi_cpp_rs_str.push_str("    /// Wrapper type for passing Wayland resource references between Rust and C++\n");
    ffi_cpp_rs_str.push_str("    #[derive(Clone)]\n");
    ffi_cpp_rs_str.push_str("    pub struct WaylandResource {\n");
    ffi_cpp_rs_str.push_str("        pub object_id: u32,\n");
    ffi_cpp_rs_str.push_str("    }\n\n");
    ffi_cpp_rs_str.push_str("    /// Wrapper type for optional Wayland resource references\n");
    ffi_cpp_rs_str.push_str("    #[derive(Clone)]\n");
    ffi_cpp_rs_str.push_str("    pub struct OptionalWaylandResource {\n");
    ffi_cpp_rs_str.push_str("        pub object_id: u32,\n");
    ffi_cpp_rs_str.push_str("        pub is_null: bool,\n");
    ffi_cpp_rs_str.push_str("    }\n\n");
    ffi_cpp_rs_str.push_str("    unsafe extern \"C++\" {\n");
    
    // Placeholder for includes - will be replaced after headers are generated
    ffi_cpp_rs_str.push_str("        /* HEADER_INCLUDES_PLACEHOLDER */\n\n");

    let mut all_interface_info: HashMap<String, InterfaceInfo> = HashMap::new();
    // Track which interfaces create which child interfaces (parent -> Vec<child>)
    let mut parent_to_children: HashMap<String, Vec<(String, String)>> = HashMap::new(); // parent -> Vec<(child_interface, request_name)>

    for protocol_file in wayland_protocols_xml_dir {
        let path = protocol_file.unwrap().path();
        if path.extension().and_then(|s| s.to_str()) == Some("xml") {
            // First, generate the generator macros.
            let protocol_name = path.file_stem().and_then(|s| s.to_str()).unwrap();
            if protocol_name != "wayland" {
                protocol_rs_str.push_str(&format!("pub mod {} {{\n", protocol_name.replace('-', "_")));
                protocol_rs_str.push_str("    use wayland_server;\n");
                protocol_rs_str.push_str("    use wayland_server::protocol::*;\n");
                protocol_rs_str.push_str("    use wayland_server::protocol::__interfaces::*;\n");

                // TODO: We can probably be smarter and read the protocol to parse out its dependencies,
                // but this is easy enough for now.
                if protocol_name == "xdg-decoration-unstable-v1" || protocol_name == "xdg-activation-v1" || protocol_name == "wlr-layer-shell-unstable-v1" {
                    protocol_rs_str.push_str("    use crate::protocols::xdg_shell::*;\n");
                }

                if protocol_name == "input-method-unstable-v2" {
                    protocol_rs_str.push_str("    use crate::protocols::text_input_unstable_v3::*;\n");
                }

                if protocol_name == "ext-image-capture-source-v1" {
                    protocol_rs_str.push_str("    use crate::protocols::ext_foreign_toplevel_list_v1::*;\n");
                }

                if protocol_name == "ext-image-copy-capture-v1" {
                    protocol_rs_str.push_str("    use crate::protocols::ext_image_capture_source_v1::*;\n");
                    protocol_rs_str.push_str("    use crate::protocols::ext_image_capture_source_v1::ext_image_capture_source_v1::*;\n");
                }

                protocol_rs_str.push_str("    wayland_scanner::generate_interfaces!(\"");
                protocol_rs_str.push_str(&format!("../../wayland-protocols/{}.xml\");\n", protocol_name));
                protocol_rs_str.push_str("    wayland_scanner::generate_server_code!(\"");
                protocol_rs_str.push_str(&format!("../../wayland-protocols/{}.xml\");\n", protocol_name));
                protocol_rs_str.push_str("}\n");
            }


            // Next, generate the dispatchers.
            // TODO: This should include the "wayland" protocol as well.

            // Parse the XML to generate dispatcher implementations
            let mut reader = Reader::from_file(&path).expect("Failed to open XML file");
            reader.config_mut().trim_text(true);

            let mut interfaces = Vec::new();
            let mut created_interfaces = HashSet::new();
            let mut buf = Vec::new();
            let mut in_protocol = false;
            let mut in_interface = false;
            let mut in_request = false;
            let mut current_interface = String::new();
            let mut current_request: Option<Request> = None;
            let mut interface_requests: HashMap<String, Vec<Request>> = HashMap::new();
            let mut depth = 0;

            // First pass: collect all interfaces, created interfaces, and requests
            loop {
                match reader.read_event_into(&mut buf) {
                    Ok(Event::Start(ref e)) => {
                        depth += 1;
                        match e.name().as_ref() {
                            b"protocol" => in_protocol = true,
                            b"interface" if depth == 2 && in_protocol => {
                                in_interface = true;
                                if let Some(name_attr) = e.attributes()
                                    .filter_map(|a| a.ok())
                                    .find(|a| a.key.as_ref() == b"name") {
                                    current_interface = String::from_utf8_lossy(&name_attr.value).to_string();

                                    if current_interface != "wl_display" && current_interface != "wl_registry" {
                                        interfaces.push(current_interface.clone());
                                        interface_requests.insert(current_interface.clone(), Vec::new());
                                    }
                                }
                            },
                            b"request" if in_interface => {
                                in_request = true;
                                let mut request_name = String::new();
                                for attr in e.attributes().filter_map(|a| a.ok()) {
                                    if attr.key.as_ref() == b"name" {
                                        request_name = String::from_utf8_lossy(&attr.value).to_string();
                                        break;
                                    }
                                }
                                current_request = Some(Request {
                                    name: request_name,
                                    args: Vec::new(),
                                });
                            },
                            b"arg" if in_request => {
                                if let Some(ref mut req) = current_request {
                                    let mut arg_name = String::new();
                                    let mut arg_type = String::new();
                                    let mut arg_interface: Option<String> = None;
                                    let mut allow_null = false;
                                    let mut enum_type: Option<String> = None;

                                    for attr in e.attributes().filter_map(|a| a.ok()) {
                                        match attr.key.as_ref() {
                                            b"name" => arg_name = String::from_utf8_lossy(&attr.value).to_string(),
                                            b"type" => arg_type = String::from_utf8_lossy(&attr.value).to_string(),
                                            b"interface" => {
                                                let iface = String::from_utf8_lossy(&attr.value).to_string();
                                                created_interfaces.insert(iface.clone());
                                                arg_interface = Some(iface);
                                            },
                                            b"allow-null" => {
                                                allow_null = String::from_utf8_lossy(&attr.value) == "true";
                                            },
                                            b"enum" => {
                                                enum_type = Some(String::from_utf8_lossy(&attr.value).to_string());
                                            },
                                            _ => {}
                                        }
                                    }

                                    req.args.push(RequestArg {
                                        name: arg_name,
                                        arg_type,
                                        interface: arg_interface,
                                        allow_null,
                                        enum_type,
                                    });
                                }
                            },
                            _ => {}
                        }
                    },
                    Ok(Event::Empty(ref e)) => {
                        // Handle self-closing tags (like <arg ... />)
                        match e.name().as_ref() {
                            b"arg" if in_request => {
                                if let Some(ref mut req) = current_request {
                                    let mut arg_name = String::new();
                                    let mut arg_type = String::new();
                                    let mut arg_interface: Option<String> = None;
                                    let mut allow_null = false;
                                    let mut enum_type: Option<String> = None;

                                    for attr in e.attributes().filter_map(|a| a.ok()) {
                                        match attr.key.as_ref() {
                                            b"name" => arg_name = String::from_utf8_lossy(&attr.value).to_string(),
                                            b"type" => arg_type = String::from_utf8_lossy(&attr.value).to_string(),
                                            b"interface" => {
                                                let iface = String::from_utf8_lossy(&attr.value).to_string();
                                                created_interfaces.insert(iface.clone());
                                                arg_interface = Some(iface);
                                            },
                                            b"allow-null" => {
                                                allow_null = String::from_utf8_lossy(&attr.value) == "true";
                                            },
                                            b"enum" => {
                                                enum_type = Some(String::from_utf8_lossy(&attr.value).to_string());
                                            },
                                            _ => {}
                                        }
                                    }

                                    req.args.push(RequestArg {
                                        name: arg_name,
                                        arg_type,
                                        interface: arg_interface,
                                        allow_null,
                                        enum_type,
                                    });
                                }
                            },
                            b"request" if in_interface => {
                                // Self-closing request (no args)
                                let mut request_name = String::new();
                                for attr in e.attributes().filter_map(|a| a.ok()) {
                                    if attr.key.as_ref() == b"name" {
                                        request_name = String::from_utf8_lossy(&attr.value).to_string();
                                        break;
                                    }
                                }
                                if let Some(requests) = interface_requests.get_mut(&current_interface) {
                                    requests.push(Request {
                                        name: request_name,
                                        args: Vec::new(),
                                    });
                                }
                            },
                            _ => {}
                        }
                    },
                    Ok(Event::End(ref e)) => {
                        match e.name().as_ref() {
                            b"protocol" => in_protocol = false,
                            b"interface" => {
                                in_interface = false;
                                current_interface.clear();
                            },
                            b"request" => {
                                if let Some(req) = current_request.take() {
                                    if let Some(requests) = interface_requests.get_mut(&current_interface) {
                                        requests.push(req);
                                    }
                                }
                                in_request = false;
                            },
                            _ => {}
                        }
                        depth -= 1;
                    },
                    Ok(Event::Eof) => break,
                    Err(e) => panic!("Error parsing XML at position {}: {:?}", reader.buffer_position(), e),
                    _ => {}
                }
                buf.clear();
            }

            // Helper function to convert snake_case to PascalCase
            let to_pascal_case = |s: &str| -> String {
                s.split('_')
                    .map(|word| {
                        let mut chars = word.chars();
                        match chars.next() {
                            None => String::new(),
                            Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                        }
                    })
                    .collect()
            };

            // Store interface info for later use and build parent-child relationships
            for interface in &interfaces {
                let requests = interface_requests.get(interface).cloned().unwrap_or_default();

                // Track which child interfaces this interface creates
                for request in &requests {
                    for arg in &request.args {
                        if arg.arg_type == "new_id" {
                            if let Some(child_interface) = &arg.interface {
                                parent_to_children
                                    .entry(interface.clone())
                                    .or_insert_with(Vec::new)
                                    .push((child_interface.clone(), request.name.clone()));
                            }
                        }
                    }
                }

                all_interface_info.insert(
                    interface.clone(),
                    InterfaceInfo {
                        name: interface.clone(),
                        requests,
                    }
                );
            }

            // Generate imports for this protocol's interfaces
            for interface in &interfaces {
                let type_name = to_pascal_case(interface);
                if protocol_name != "wayland" {
                    dispatchers_rs_str.push_str(&format!(
                        "use crate::protocols::{}::{}::{};\n",
                        protocol_name.replace('-', "_"),
                        interface,
                        type_name
                    ));
                } else if interface != "wl_display" {
                    dispatchers_rs_str.push_str(&format!(
                        "use wayland_server::protocol::{}::{};\n",
                        interface,
                        type_name
                    ));
                }
            }
            dispatchers_rs_str.push('\n');

            // Generate Send/Sync trait implementations for handler types
            for interface in &interfaces {
                let type_name = to_pascal_case(interface);
                dispatchers_rs_str.push_str(&format!("unsafe impl Send for crate::ffi_cpp::ffi_cpp::{}Handler {{}}\n", type_name));
                dispatchers_rs_str.push_str(&format!("unsafe impl Sync for crate::ffi_cpp::ffi_cpp::{}Handler {{}}\n", type_name));
            }
            dispatchers_rs_str.push('\n');

            // Generate wrapper types for handler pointers (to make them Send/Sync)
            for interface in &interfaces {
                let type_name = to_pascal_case(interface);
                dispatchers_rs_str.push_str(&format!("#[repr(transparent)]\n"));
                dispatchers_rs_str.push_str(&format!("pub struct {}HandlerPtr(*mut crate::ffi_cpp::ffi_cpp::{}Handler);\n", type_name, type_name));
                dispatchers_rs_str.push_str(&format!("unsafe impl Send for {}HandlerPtr {{}}\n", type_name));
                dispatchers_rs_str.push_str(&format!("unsafe impl Sync for {}HandlerPtr {{}}\n", type_name));
                dispatchers_rs_str.push_str(&format!("impl std::ops::Deref for {}HandlerPtr {{\n", type_name));
                dispatchers_rs_str.push_str(&format!("    type Target = *mut crate::ffi_cpp::ffi_cpp::{}Handler;\n", type_name));
                dispatchers_rs_str.push_str("    fn deref(&self) -> &Self::Target { &self.0 }\n");
                dispatchers_rs_str.push_str("}\n");
            }
            dispatchers_rs_str.push('\n');

            // Determine which interfaces are globals (not created by requests)
            // First collect all interfaces created by requests
            let mut created_by_request = HashSet::new();
            for interface in &interfaces {
                if let Some(info) = all_interface_info.get(interface) {
                    for request in &info.requests {
                        for arg in &request.args {
                            if arg.arg_type == "new_id" {
                                if let Some(child_interface) = &arg.interface {
                                    created_by_request.insert(child_interface.clone());
                                }
                            }
                        }
                    }
                }
            }

            // Generate Send/Sync binder wrapper types for global interfaces
            for interface in &interfaces {
                let always_global = interface == "wl_output" || interface == "wl_seat";
                let is_global = always_global || !created_by_request.contains(interface);
                if is_global {
                    let type_name = to_pascal_case(interface);
                    dispatchers_rs_str.push_str(&format!("unsafe impl Send for crate::ffi_cpp::ffi_cpp::{}Binder {{}}\n", type_name));
                    dispatchers_rs_str.push_str(&format!("unsafe impl Sync for crate::ffi_cpp::ffi_cpp::{}Binder {{}}\n", type_name));
                    dispatchers_rs_str.push_str(&format!("#[repr(transparent)]\n"));
                    dispatchers_rs_str.push_str(&format!("pub struct {}BinderPtr(pub *const crate::ffi_cpp::ffi_cpp::{}Binder);\n", type_name, type_name));
                    dispatchers_rs_str.push_str(&format!("unsafe impl Send for {}BinderPtr {{}}\n", type_name));
                    dispatchers_rs_str.push_str(&format!("unsafe impl Sync for {}BinderPtr {{}}\n", type_name));
                    dispatchers_rs_str.push_str(&format!("impl std::ops::Deref for {}BinderPtr {{\n", type_name));
                    dispatchers_rs_str.push_str(&format!("    type Target = *const crate::ffi_cpp::ffi_cpp::{}Binder;\n", type_name));
                    dispatchers_rs_str.push_str("    fn deref(&self) -> &Self::Target { &self.0 }\n");
                    dispatchers_rs_str.push_str("}\n");
                }
            }
            dispatchers_rs_str.push('\n');

            // Generate trait implementations
            for interface in &interfaces {
                let type_name = to_pascal_case(interface);
                // Core Wayland interfaces that are always globals, even if they appear in new_id elsewhere
                let always_global = interface == "wl_output" || interface == "wl_seat";
                let is_global = always_global || !created_interfaces.contains(interface);
                let handler_wrapper_type = format!("{}HandlerPtr", type_name);

                // Generate GlobalDispatch for globals only
                if is_global {
                    dispatchers_rs_str.push_str(&format!(
                        "impl wayland_server::GlobalDispatch<{}, {}BinderPtr> for crate::ServerState {{\n",
                        type_name, type_name
                    ));
                    dispatchers_rs_str.push_str("    fn bind(\n");
                    dispatchers_rs_str.push_str("        _state: &mut Self,\n");
                    dispatchers_rs_str.push_str("        _handle: &wayland_server::DisplayHandle,\n");
                    dispatchers_rs_str.push_str("        _client: &wayland_server::Client,\n");
                    dispatchers_rs_str.push_str(&format!("        resource: wayland_server::New<{}>,\n", type_name));
                    dispatchers_rs_str.push_str(&format!("        _global_data: &{}BinderPtr,\n", type_name));
                    dispatchers_rs_str.push_str("        data_init: &mut wayland_server::DataInit<'_, Self>,\n");
                    dispatchers_rs_str.push_str("    ) {\n");
                    dispatchers_rs_str.push_str("        let binder = unsafe { (**_global_data).as_ref().expect(\"Binder pointer is null\") };\n");
                    dispatchers_rs_str.push_str("        let handler = binder.create_handler();\n");
                    dispatchers_rs_str.push_str(&format!("        data_init.init(resource, {}HandlerPtr(handler));\n", type_name));
                    dispatchers_rs_str.push_str("    }\n");
                    dispatchers_rs_str.push_str("}\n\n");
                }

                // Generate Dispatch for all interfaces
                dispatchers_rs_str.push_str(&format!(
                    "impl wayland_server::Dispatch<{}, {}> for crate::ServerState {{\n",
                    type_name, handler_wrapper_type
                ));
                dispatchers_rs_str.push_str("    fn request(\n");
                dispatchers_rs_str.push_str("        _state: &mut Self,\n");
                dispatchers_rs_str.push_str("        _client: &wayland_server::Client,\n");
                dispatchers_rs_str.push_str(&format!("        _resource: &{},\n", type_name));
                dispatchers_rs_str.push_str(&format!("        request: <{} as wayland_server::Resource>::Request,\n", type_name));
                dispatchers_rs_str.push_str(&format!("        data: &{},\n", handler_wrapper_type));
                dispatchers_rs_str.push_str("        _dhandle: &wayland_server::DisplayHandle,\n");
                dispatchers_rs_str.push_str("        _data_init: &mut wayland_server::DataInit<'_, Self>,\n");
                dispatchers_rs_str.push_str("    ) {\n");
                dispatchers_rs_str.push('\n');

                // Get the requests for this interface
                let interface_info = all_interface_info.get(interface);
                if let Some(info) = interface_info {
                    if !info.requests.is_empty() {
                        dispatchers_rs_str.push_str("        use crate::ffi_cpp::ffi_cpp::*;\n");
                        let type_name = to_pascal_case(interface);
                        if protocol_name != "wayland" {
                            dispatchers_rs_str.push_str(&format!(
                                "        use crate::protocols::{}::{}::Request as {}Request;;\n",
                                protocol_name.replace('-', "_"),
                                interface,
                                type_name
                            ));
                        } else if interface != "wl_display" {
                            dispatchers_rs_str.push_str(&format!(
                                "        use wayland_server::protocol::{}::Request as {}Request;\n",
                                interface,
                                type_name
                            ));
                        }

                        dispatchers_rs_str.push_str("        match request {\n");

                        for request in &info.requests {
                            let request_variant = to_pascal_case(&request.name);
                            dispatchers_rs_str.push_str(&format!("            {}Request::{}", type_name, request_variant));

                            if request.args.is_empty() {
                                dispatchers_rs_str.push_str(" => {\n");
                            } else {
                                dispatchers_rs_str.push_str(" { ");
                                for (i, arg) in request.args.iter().enumerate() {
                                    if i > 0 {
                                        dispatchers_rs_str.push_str(", ");
                                    }
                                    dispatchers_rs_str.push_str(&arg.name);
                                }
                                dispatchers_rs_str.push_str(" } => {\n");
                            }

                            // Check if we need to initialize any new_id resources first
                            let has_new_id = request.args.iter().any(|arg| arg.arg_type == "new_id");

                            // Two-phase initialization for new_id resources
                            // Phase 1: Call handle_* method to get handler (or create from factory)
                            if has_new_id {
                                dispatchers_rs_str.push_str("                // Phase 1: Get handler from handle_* method or factory\n");
                                for arg in &request.args {
                                    if arg.arg_type == "new_id" {
                                        if let Some(child_interface_name) = &arg.interface {
                                            let child_type_name = to_pascal_case(child_interface_name);

                                            // Determine if this child is created by the parent handler or factory
                                            let is_child_of_parent = parent_to_children
                                                .get(interface)
                                                .map(|children| children.iter().any(|(child, _)| child == child_interface_name))
                                                .unwrap_or(false);

                                            if is_child_of_parent {
                                                // Child handler will be returned by handle_* method
                                                dispatchers_rs_str.push_str(&format!(
                                                    "                let mut {}_handler: *mut crate::ffi_cpp::ffi_cpp::{}Handler = std::ptr::null_mut();\n",
                                                    arg.name, child_type_name
                                                ));
                                            } else {
                                                // Child is a global, created by factory
                                                dispatchers_rs_str.push_str(&format!(
                                                    "                let {}_handler = factory.create_{}_handler();\n",
                                                    arg.name, child_interface_name
                                                ));
                                            }
                                        } else {
                                            // No interface means generic object - we can't create a handler yet
                                            dispatchers_rs_str.push_str(&format!(
                                                "                let {}_handler = std::ptr::null_mut();\n",
                                                arg.name
                                            ));
                                        }
                                    }
                                }
                                dispatchers_rs_str.push('\n');
                            }

                            // Generate handler call
                            dispatchers_rs_str.push_str("                unsafe {\n");
                            dispatchers_rs_str.push_str("                    if let Some(handler) = data.0.as_ref() {\n");

                            // If this creates a new_id from parent, capture the return value
                            let creates_child_from_parent = has_new_id && request.args.iter().any(|arg| {
                                arg.arg_type == "new_id" && arg.interface.is_some() &&
                                parent_to_children.get(interface)
                                    .map(|children| children.iter().any(|(child, _)| Some(child) == arg.interface.as_ref()))
                                    .unwrap_or(false)
                            });

                            if creates_child_from_parent {
                                let new_id_arg = request.args.iter().find(|arg| {
                                    arg.arg_type == "new_id" && arg.interface.is_some()
                                }).unwrap();
                                dispatchers_rs_str.push_str(&format!("                        {}_handler = handler.handle_{}(", new_id_arg.name, request.name));
                            } else {
                                dispatchers_rs_str.push_str(&format!("                        handler.handle_{}(", request.name));
                            }

                            let mut first_arg = true;
                            for arg in &request.args {
                                // Skip new_id args - they're not passed to handle_* anymore
                                if arg.arg_type == "new_id" {
                                    continue;
                                }

                                if !first_arg {
                                    dispatchers_rs_str.push_str(", ");
                                }
                                first_arg = false;

                                // Convert arguments as needed
                                match arg.arg_type.as_str() {
                                    "string" => {
                                        if arg.allow_null {
                                            dispatchers_rs_str.push_str(&format!("{}.as_deref().unwrap_or(\"\")", arg.name));
                                        } else {
                                            dispatchers_rs_str.push_str(&format!("{}.as_str()", arg.name));
                                        }
                                    },
                                    "object" => {
                                        if arg.allow_null {
                                            dispatchers_rs_str.push_str(&format!(
                                                "&OptionalWaylandResource {{ object_id: {}.as_ref().map(|o| o.id().protocol_id()).unwrap_or(0), is_null: {}.is_none() }}",
                                                arg.name, arg.name
                                            ));
                                        } else {
                                            dispatchers_rs_str.push_str(&format!(
                                                "&WaylandResource {{ object_id: {}.id().protocol_id() }}",
                                                arg.name
                                            ));
                                        }
                                    },
                                    "array" => {
                                        dispatchers_rs_str.push_str(&format!("{}.as_slice()", arg.name));
                                    },
                                    "uint" => {
                                        dispatchers_rs_str.push_str(&format!("{}.into()", arg.name));
                                    },
                                    "fd" => {
                                        dispatchers_rs_str.push_str(&format!("{}.as_raw_fd()", arg.name));
                                    },
                                    _ => {
                                        // Use special handling for enum types (WEnum)
                                        if arg.enum_type.is_some() {
                                            // WEnum types need to be converted with .into_result().map(|v| v as i32).unwrap_or(0)
                                            dispatchers_rs_str.push_str(&format!("{}.into_result().map(|v| v as i32).unwrap_or(0)", arg.name));
                                        } else {
                                            dispatchers_rs_str.push_str(&arg.name);
                                        }
                                    }
                                }
                            }

                            dispatchers_rs_str.push_str(");\n");
                            dispatchers_rs_str.push_str("                    }\n");
                            dispatchers_rs_str.push_str("                }\n");

                            // Phase 2: Initialize resources with handlers
                            if has_new_id {
                                dispatchers_rs_str.push_str("\n                // Phase 2: Initialize resources\n");
                                for arg in &request.args {
                                    if arg.arg_type == "new_id" {
                                        if arg.interface.is_some() {
                                            let child_type_name = to_pascal_case(arg.interface.as_ref().unwrap());
                                            dispatchers_rs_str.push_str(&format!(
                                                "                let {}_initialized = _data_init.init({}, {}HandlerPtr({}_handler));\n",
                                                arg.name, arg.name, child_type_name, arg.name
                                            ));
                                        } else {
                                            dispatchers_rs_str.push_str(&format!(
                                                "                let {}_initialized = _data_init.init({}, std::ptr::null_mut());\n",
                                                arg.name, arg.name
                                            ));
                                        }
                                    }
                                }

                                // Phase 3: Set resource IDs on handlers
                                dispatchers_rs_str.push_str("\n                // Phase 3: Set resource IDs on handlers\n");
                                for arg in &request.args {
                                    if arg.arg_type == "new_id" && arg.interface.is_some() {
                                        dispatchers_rs_str.push_str("                unsafe {\n");
                                        dispatchers_rs_str.push_str(&format!(
                                            "                    if let Some(handler) = {}_handler.as_ref() {{\n",
                                            arg.name
                                        ));
                                        dispatchers_rs_str.push_str(&format!(
                                            "                        handler.set_resource_id({}_initialized.id().protocol_id());\n",
                                            arg.name
                                        ));
                                        dispatchers_rs_str.push_str("                    }\n");
                                        dispatchers_rs_str.push_str("                }\n");
                                    }
                                }
                            }

                            dispatchers_rs_str.push_str("            }\n");
                        }

                        dispatchers_rs_str.push_str("            _ => {}\n");
                        dispatchers_rs_str.push_str("        }\n");
                    } else {
                        dispatchers_rs_str.push_str("        match request {\n");
                        dispatchers_rs_str.push_str("            _ => {}\n");
                        dispatchers_rs_str.push_str("        }\n");
                    }
                } else {
                    dispatchers_rs_str.push_str("        match request {\n");
                    dispatchers_rs_str.push_str("            _ => {}\n");
                    dispatchers_rs_str.push_str("        }\n");
                }

                dispatchers_rs_str.push_str("    }\n");
                dispatchers_rs_str.push_str("}\n\n");
            }

        }
    }

    // Helper function to convert snake_case to PascalCase
    let to_pascal_case = |s: &str| -> String {
        s.split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                }
            })
            .collect()
    };

    // Helper function to convert Wayland type to Rust type for cxx
    let wayland_type_to_rust = |arg_type: &str, allow_null: bool| -> String {
        match arg_type {
            "int" => "i32".to_string(),
            "uint" => "u32".to_string(),
            "fixed" => "f64".to_string(),  // Wayland fixed-point is represented as i32
            "string" => "&str".to_string(),
            "object" | "new_id" => {
                if allow_null {
                    "&OptionalWaylandResource".to_string()
                } else {
                    "&WaylandResource".to_string()
                }
            },
            "array" => "&[u8]".to_string(),
            "fd" => "i32".to_string(),  // File descriptor
            _ => "i32".to_string(),  // Default fallback
        }
    };

    // Helper function to sanitize argument names (avoid C++ keywords)
    let sanitize_arg_name = |name: &str| -> String {
        match name {
            "namespace" => "namespace_".to_string(),
            "class" => "class_".to_string(),
            "template" => "template_".to_string(),
            "operator" => "operator_".to_string(),
            "delete" => "delete_".to_string(),
            "new" => "new_".to_string(),
            _ => name.to_string(),
        }
    };

    // Generate ffi_cpp handler types and methods
    for (interface_name, interface_info) in &all_interface_info {
        let type_name = to_pascal_case(interface_name);

        // Declare handler type
        ffi_cpp_rs_str.push_str(&format!("        pub type {}Handler;\n", type_name));

        // Declare handler methods for each request
        for request in &interface_info.requests {
            let method_name = format!("handle_{}", request.name);

            // Check if this request creates a new_id (returns handler pointer)
            let creates_new_id = request.args.iter().any(|arg| arg.arg_type == "new_id" && arg.interface.is_some());
            let return_type = if creates_new_id {
                // Find the new_id arg to get the interface type
                let new_id_arg = request.args.iter().find(|arg| arg.arg_type == "new_id" && arg.interface.is_some()).unwrap();
                let child_type_name = to_pascal_case(new_id_arg.interface.as_ref().unwrap());
                format!(" -> *mut {}Handler", child_type_name)
            } else {
                String::new()
            };

            ffi_cpp_rs_str.push_str(&format!("        pub fn {}(self: &{}Handler", method_name, type_name));

            // Add parameters, skipping new_id args
            for arg in &request.args {
                if arg.arg_type != "new_id" {
                    let rust_type = wayland_type_to_rust(&arg.arg_type, arg.allow_null);
                    let arg_name = sanitize_arg_name(&arg.name);
                    ffi_cpp_rs_str.push_str(&format!(", {}: {}", arg_name, rust_type));
                }
            }

            ffi_cpp_rs_str.push_str(&format!("){}", return_type));
            ffi_cpp_rs_str.push_str(";\n");
        }

        // Add child creation methods for interfaces this handler can create
        if let Some(children) = parent_to_children.get(interface_name) {
            // Deduplicate children (same interface might be created by multiple requests)
            let mut unique_children = HashSet::new();
            for (child_interface, _) in children {
                unique_children.insert(child_interface);
            }

        }

        // Add set_resource_id method for all handlers
        ffi_cpp_rs_str.push_str(&format!(
            "        pub fn set_resource_id(self: &{}Handler, resource_id: u32);\n",
            type_name
        ));

        ffi_cpp_rs_str.push('\n');
    }

    // Declare Binder types for global interfaces
    // Binder types are used to create handlers when clients bind to globals
    // Collect all child interfaces (those created by other interfaces)
    let mut child_interfaces = HashSet::new();
    for (_, children) in &parent_to_children {
        for (child_interface, _) in children {
            child_interfaces.insert(child_interface.as_str());
        }
    }

    // Create Binder type for each global interface
    for interface_name in all_interface_info.keys() {
        if !child_interfaces.contains(interface_name.as_str()) {
            let type_name = to_pascal_case(interface_name);
            ffi_cpp_rs_str.push_str(&format!("        pub type {}Binder;\n", type_name));
            ffi_cpp_rs_str.push_str(&format!(
                "        pub fn create_handler(self: &{}Binder) -> *mut {}Handler;\n",
                type_name, type_name
            ));
        }
    }
    ffi_cpp_rs_str.push('\n');

    ffi_cpp_rs_str.push_str("    }\n");
    ffi_cpp_rs_str.push_str("}\n");

    // Generate separate C++ header file for each handler class
    // Track all generated headers for inclusion in ffi_cpp
    let mut generated_headers = Vec::new();

    // Helper function to convert Wayland type to C++ type
    let wayland_type_to_cpp = |arg_type: &str, allow_null: bool| -> String {
        match arg_type {
            "int" => "int32_t".to_string(),
            "uint" => "uint32_t".to_string(),
            "fixed" => "double".to_string(),
            "string" => "rust::Str".to_string(),
            "object" | "new_id" => {
                if allow_null {
                    "OptionalWaylandResource const&".to_string()
                } else {
                    "WaylandResource const&".to_string()
                }
            },
            "array" => "rust::Slice<const uint8_t>".to_string(),
            "fd" => "int32_t".to_string(),
            _ => "int32_t".to_string(),
        }
    };

    // Collect all child interfaces (those created by other interfaces)
    let mut child_interfaces_cpp = HashSet::new();
    for (_, children) in &parent_to_children {
        for (child_interface, _) in children {
            child_interfaces_cpp.insert(child_interface.as_str());
        }
    }

    // Generate header file for each handler
    for (interface_name, interface_info) in &all_interface_info {
        let type_name = to_pascal_case(interface_name);
        let header_filename = format!("{}_handler.h", interface_name);
        let header_path = Path::new(&out_dir).join(&header_filename);
        
        let mut cpp_header_str = String::from("// This file is autogenerated by build.rs\n\n");
        let header_guard = format!("MIR_WAYLAND_{}_HANDLER_H", interface_name.to_uppercase());
        cpp_header_str.push_str(&format!("#ifndef {}\n#define {}\n\n", header_guard, header_guard));
        cpp_header_str.push_str("#include <cstdint>\n\n");
        cpp_header_str.push_str("#include <rust/cxx.h>\n");
        cpp_header_str.push_str("#include <wayland-server-core.h>\n\n");
        cpp_header_str.push_str("namespace mir::wayland_rs::cpp {\n\n");
        
        // Forward declarations for wrapper types (needed by all handlers)
        cpp_header_str.push_str("// Forward declarations for wrapper types\n");
        cpp_header_str.push_str("struct WaylandResource;\n");
        cpp_header_str.push_str("struct OptionalWaylandResource;\n\n");

        // Forward declarations for handler types that this handler creates
        let mut needs_forward_decls = HashSet::new();
        for request in &interface_info.requests {
            for arg in &request.args {
                if arg.arg_type == "new_id" {
                    if let Some(child_interface) = &arg.interface {
                        let child_type_name = to_pascal_case(child_interface);
                        needs_forward_decls.insert(child_type_name);
                    }
                }
            }
        }

        if !needs_forward_decls.is_empty() {
            cpp_header_str.push_str("// Forward declarations for child handler types\n");
            for child_type in &needs_forward_decls {
                cpp_header_str.push_str(&format!("class {}Handler;\n", child_type));
            }
            cpp_header_str.push_str("\n");
        }

        // Generate handler class
        cpp_header_str.push_str(&format!("/// Handler for {} Wayland protocol interface\n", interface_name));
        cpp_header_str.push_str(&format!("class {}Handler {{\n", type_name));
        cpp_header_str.push_str("public:\n");
        cpp_header_str.push_str(&format!("    virtual ~{}Handler() = default;\n\n", type_name));

        // Generate virtual methods for each request
        for request in &interface_info.requests {
            let method_name = format!("handle_{}", request.name);

            // Check if this request creates a new_id (returns handler pointer)
            let creates_new_id = request.args.iter().any(|arg| arg.arg_type == "new_id" && arg.interface.is_some());
            let return_type = if creates_new_id {
                // Find the new_id arg to get the interface type
                let new_id_arg = request.args.iter().find(|arg| arg.arg_type == "new_id" && arg.interface.is_some()).unwrap();
                let child_type_name = to_pascal_case(new_id_arg.interface.as_ref().unwrap());
                format!("{}Handler*", child_type_name)
            } else {
                "void".to_string()
            };

            cpp_header_str.push_str(&format!("    virtual {} {}(", return_type, method_name));

            // Add parameters, skipping new_id args
            let mut first_param = true;
            for arg in &request.args {
                if arg.arg_type != "new_id" {
                    if !first_param {
                        cpp_header_str.push_str(", ");
                    }
                    first_param = false;

                    let cpp_type = wayland_type_to_cpp(&arg.arg_type, arg.allow_null);
                    let arg_name = sanitize_arg_name(&arg.name);
                    cpp_header_str.push_str(&format!("{} {}", cpp_type, arg_name));
                }
            }

            cpp_header_str.push_str(") const = 0;\n");
        }

        cpp_header_str.push_str("\n    /// Set the resource ID after initialization\n");
        cpp_header_str.push_str("    virtual void set_resource_id(uint32_t resource_id) const = 0;\n");

        cpp_header_str.push_str("};\n\n");

        // Close namespace
        cpp_header_str.push_str("}  // namespace mir::wayland_rs::cpp\n\n");
        cpp_header_str.push_str(&format!("#endif // {}\n", header_guard));

        // Write the header file
        fs::write(&header_path, cpp_header_str).unwrap();
        generated_headers.push(header_filename);
    }

    // Generate header files for Binder classes (for global interfaces)
    for interface_name in all_interface_info.keys() {
        if !child_interfaces_cpp.contains(interface_name.as_str()) {
            let type_name = to_pascal_case(interface_name);
            let binder_filename = format!("{}_binder.h", interface_name);
            let binder_path = Path::new(&out_dir).join(&binder_filename);

            let mut cpp_binder_str = String::from("// This file is autogenerated by build.rs\n\n");
            let header_guard = format!("MIR_WAYLAND_{}_BINDER_H", interface_name.to_uppercase());
            cpp_binder_str.push_str(&format!("#ifndef {}\n#define {}\n\n", header_guard, header_guard));
            cpp_binder_str.push_str("#include <cstdint>\n\n");
            
            // Include the handler header for this interface
            cpp_binder_str.push_str(&format!("#include \"{}_handler.h\"\n\n", interface_name));
            
            cpp_binder_str.push_str("namespace mir::wayland_rs::cpp {\n\n");

            cpp_binder_str.push_str(&format!(
                "/// Binder for creating {} handlers when clients bind to the global\n",
                interface_name
            ));
            cpp_binder_str.push_str(&format!(
                "/// Passed to create_{}_global() and called when a client binds\n",
                interface_name
            ));
            cpp_binder_str.push_str(&format!("class {}Binder {{\n", type_name));
            cpp_binder_str.push_str("public:\n");
            cpp_binder_str.push_str(&format!("    virtual ~{}Binder() = default;\n\n", type_name));
            cpp_binder_str.push_str(&format!(
                "    virtual {}Handler* create_handler() const = 0;\n",
                type_name
            ));
            cpp_binder_str.push_str("};\n\n");

            // Close namespace
            cpp_binder_str.push_str("}  // namespace mir::wayland_rs::cpp\n\n");
            cpp_binder_str.push_str(&format!("#endif // {}\n", header_guard));

            // Write the binder header file
            fs::write(&binder_path, cpp_binder_str).unwrap();
            generated_headers.push(binder_filename);
        }
    }

    // Now update ffi_cpp_rs_str to include all generated headers
    let mut ffi_cpp_includes = String::new();
    for header in &generated_headers {
        ffi_cpp_includes.push_str(&format!("        include!(\"{}\");\n", header));
    }
    
    // Replace the placeholder with actual includes
    let ffi_cpp_with_includes = ffi_cpp_rs_str.replace(
        "        /* HEADER_INCLUDES_PLACEHOLDER */",
        &ffi_cpp_includes.trim_end()
    );

    // Generate global creation methods
    let mut globals_rs_str = String::from("// This file is autogenerated by build.rs\n\n");
    globals_rs_str.push_str("impl WaylandServer {\n");

    // Collect global interfaces (those not created by other interfaces)
    let mut global_interfaces = Vec::new();
    for (interface_name, _) in &all_interface_info {
        // Skip wl_display and wl_registry as they're handled specially
        if interface_name != "wl_display" && interface_name != "wl_registry" {
            // Check if this interface is created by another interface
            let mut is_created_by_other = false;
            for (_, info) in &all_interface_info {
                for request in &info.requests {
                    for arg in &request.args {
                        if arg.arg_type == "new_id" {
                            if let Some(iface) = &arg.interface {
                                if iface == interface_name {
                                    is_created_by_other = true;
                                    break;
                                }
                            }
                        }
                    }
                    if is_created_by_other {
                        break;
                    }
                }
                if is_created_by_other {
                    break;
                }
            }

            if !is_created_by_other {
                global_interfaces.push(interface_name.clone());
            }
        }
    }

    // Sort for consistent output
    global_interfaces.sort();

    // Generate a method for each global interface
    for interface_name in &global_interfaces {
        let type_name = to_pascal_case(interface_name);
        let method_name = format!("create_{}_global", interface_name);

        // Determine the import path
        let import_path = if interface_name.starts_with("wl_") {
            format!("wayland_server::protocol::{}::{}", interface_name, type_name)
        } else {
            // Find which protocol this interface belongs to
            let mut protocol_name = None;
            'outer: for protocol_file in fs::read_dir("../../wayland-protocols").unwrap() {
                let path = protocol_file.unwrap().path();
                if path.extension().and_then(|s| s.to_str()) == Some("xml") {
                    let protocol = path.file_stem().and_then(|s| s.to_str()).unwrap();
                    if protocol != "wayland" {
                        // Check if this interface is in this protocol
                        let mut reader = Reader::from_file(&path).expect("Failed to open XML file");
                        reader.config_mut().trim_text(true);
                        let mut buf = Vec::new();
                        loop {
                            match reader.read_event_into(&mut buf) {
                                Ok(Event::Start(ref e)) if e.name().as_ref() == b"interface" => {
                                    if let Some(name_attr) = e.attributes()
                                        .filter_map(|a| a.ok())
                                        .find(|a| a.key.as_ref() == b"name") {
                                        let iface_name = String::from_utf8_lossy(&name_attr.value).to_string();
                                        if &iface_name == interface_name {
                                            protocol_name = Some(protocol.to_string());
                                            break 'outer;
                                        }
                                    }
                                },
                                Ok(Event::Eof) => break,
                                Err(e) => panic!("Error parsing XML: {:?}", e),
                                _ => {}
                            }
                            buf.clear();
                        }
                    }
                }
            }

            if let Some(protocol) = protocol_name {
                format!("crate::protocols::{}::{}::{}", protocol.replace('-', "_"), interface_name, type_name)
            } else {
                // Fallback, shouldn't happen
                format!("{}::{}", interface_name, type_name)
            }
        };

        globals_rs_str.push_str(&format!("    /// Create a global for the {} protocol\n", interface_name));
        globals_rs_str.push_str(&format!("    /// The binder is called when clients bind to this global to create handler instances\n"));
        globals_rs_str.push_str(&format!("    /// Returns a unique ID that maps to the GlobalId internally\n"));
        globals_rs_str.push_str(&format!("    pub fn {}(&mut self, version: u32, binder: usize) -> u64 {{\n", method_name));
        globals_rs_str.push_str(&format!("        use {};\n", import_path));
        globals_rs_str.push_str(&format!("        use crate::dispatchers::{}BinderPtr;\n", type_name));
        globals_rs_str.push_str("        \n");
        globals_rs_str.push_str(&format!("        let binder_ptr = binder as *const crate::ffi_cpp::ffi_cpp::{}Binder;\n", type_name));
        globals_rs_str.push_str("        let display_handle = self.display.handle();\n");
        globals_rs_str.push_str(&format!(
            "        let global_id = display_handle.create_global::<crate::ServerState, {}, {}BinderPtr>(version, {}BinderPtr(binder_ptr));\n",
            type_name, type_name, type_name
        ));
        globals_rs_str.push_str("        \n");
        globals_rs_str.push_str("        // Store the GlobalId and return a unique integer ID\n");
        globals_rs_str.push_str("        let id = {\n");
        globals_rs_str.push_str("            let mut next_id = self.next_global_id.lock().unwrap();\n");
        globals_rs_str.push_str("            let id = *next_id;\n");
        globals_rs_str.push_str("            *next_id += 1;\n");
        globals_rs_str.push_str("            id\n");
        globals_rs_str.push_str("        };\n");
        globals_rs_str.push_str("        self.globals.lock().unwrap().insert(id, global_id);\n");
        globals_rs_str.push_str("        id\n");
        globals_rs_str.push_str("    }\n\n");
    }

    globals_rs_str.push_str("}\n");

    // Generate FFI bridge declarations for all global creation methods
    let mut ffi_bridge_str = String::from("// This file is autogenerated by build.rs\n");
    ffi_bridge_str.push_str("// Include this in the extern \"Rust\" block of the ffi_rust bridge\n\n");

    for interface_name in &global_interfaces {
        let type_name = to_pascal_case(interface_name);
        let method_name = format!("create_{}_global", interface_name);
        ffi_bridge_str.push_str(&format!("        fn {}(self: &mut WaylandServer, version: u32, binder: *const {}Binder) -> u64;\n", method_name, type_name));
    }

    fs::write(
        &protocol_dest_path,
        protocol_rs_str
    ).unwrap();
    fs::write(
        &dispatchers_dest_path,
        dispatchers_rs_str
    ).unwrap();
    fs::write(
        &ffi_cpp_dest_path,
        ffi_cpp_with_includes
    ).unwrap();
    fs::write(
        &globals_dest_path,
        globals_rs_str
    ).unwrap();
    fs::write(
        &ffi_bridge_dest_path,
        ffi_bridge_str
    ).unwrap();

    // Now build the cxx bridges after generating the required files
    // The lib.rs file includes both ffif_rust and ffi_cpp modules
    cxx_build::bridges(vec!["src/lib.rs", "src/ffi_cpp.rs"])
        .include(&out_dir) // Include OUT_DIR for generated handler headers
        .compile("wayland_rs");

    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=../../wayland-protocols");
    println!("cargo:rerun-if-changed=build.rs");
}
